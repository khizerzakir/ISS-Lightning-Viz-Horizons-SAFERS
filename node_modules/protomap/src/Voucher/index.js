import {Entry} from '../Entry';
import {Cascade} from '../Cascade';
import {decompose} from './decompose-norm';


// 我们有两种情况会用到Voucher：

// 1. 当我们读取序时帐并创建一条分录时
//    此时我们会直接使用构造函数。通过判断是否存在LineID来确定我们
//    是在创建一条凭证行还是在创建一个完整凭证。

// 2. 当我们汇总属于同一个凭证的若干行，并创建一条新的行时。
//    此时我们会使用静态方法from，在from中用到构造函数时可以保证lineID
//    是不存在的。

export class Voucher extends Entry {

  constructor({year, month, billDate, desc, voucherID, lineID, ...args}={}, opts){
    super(args, opts);

    this.billDate = billDate;

    this.year = year ?? billDate.getFullYear();
    this.month = month ?? billDate.getMonth();
    this.desc = desc;

    this.voucherID = lineID === undefined ? `${voucherID}` : `${this.year}-${this.month}-${voucherID}-${lineID}`;
  }

  copy(opts={}) {
    return new Voucher(this, opts);
  }

  add(voucher) {
    this.accrual.add(voucher.accrual);
  }

  static from(list, {voucherID, ListCons=Cascade, decompose=false, emptyIdentity=false}={}) {

    if (list.some(entry => !(entry instanceof Voucher))) {
      throw Error('Voucher.from: voucher must be formed from list of Entry');
    }

    const voucher = new Voucher(list[0], {emptyAccrual: true, emptyIdentity});
    for (let entry of list) {
      voucher.add(entry);
      entry.move(voucher, {pushSide:'TAIL'});
    }

    if (voucherID !== undefined) {
      voucher.voucherID = voucherID;
    }

    if (decompose) {
      voucher.decomposeNorm();
    }

    return voucher;
  }

  copy(){
    return new Voucher(this);
  }

  decomposeNorm() {
    this.succ = decompose(this.succ);
  }

}