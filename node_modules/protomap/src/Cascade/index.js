import {List} from '../List';
import {Entry} from '../Entry';
import {Rule} from '../Rule';

import { isInherited } from '../util';

import {propFunc} from '../prop-func';
import mergeMethods from '../merge-methods';

export class Cascade extends List {
  constructor(...args){
    super(...args);
  }

  static from(list, {EntryCons=Entry, ListCons=Cascade}={}) {

    if (!isInherited(EntryCons, Entry)) {
      throw Error('List.from: Entry constructor must inherits from Entry');
    }

    const cate = new Cascade();
    for (let elem of list) {
      cate.push(new EntryCons(elem, {ListCons}));
    }
    return cate;
  }

  flat() {

    if (this.attr.form !== 'NESTED') {
      throw Error('Cascade.flat: cannot flat an unnested list');
    }

    const stack = [...this];
    const res = new Cascade();

    while(stack.length) {
      const next = stack.shift();
      const {succ} = next;
      if(succ.constructor === Cascade && succ.length > 0) {
        stack.unshift(...succ);
      }
      res.push(next);
    }
    return res;
  }

  nest({genKey, matchKey, nestKey}={}) {

    if (this.some(({curr:{code}}) => typeof code !== 'string' )) {
      throw Error('Cascade.nest: code must be string');
    }

    if (this.attr.form === 'NESTED') {
      throw Error('Cascade.nest: code must nested')
    }

    if (this.every(elem => !(elem instanceof Entry))){
      throw Error('Cascade.nest: all elements must be Entry in order to nest');
    }

    const [genFunc, matchFunc] = (genKey && matchKey)
      ? [genKey, matchKey]
      : nestKey
      ? [
          rec => propFunc(rec, nestKey).length, 
          (pred, succ) => propFunc(succ, nestKey).startsWith(propFunc(pred, nestKey))
        ]
      : [
          ({curr:{code}}) => code.length,
          ({curr:pred}, {curr:succ}) => succ.code.startsWith(pred.code)
        ]

    for (let elem of this) {
      elem.succ = new Cascade();
    }

    // grip使用了genFunc，将列表分为几代（Generation）
    // gens是分代的结果，分代结果应该是祖先在前，后继在后。
    const gens = this.orderBy(genFunc).grip(genFunc).grap();

    // 对于所有分代
    let gen;
    for (gen = gens.pop(); gens.length > 0; gen = gens.pop()) {
      let preds = gens.pop();
      
      // 在两代中间进行匹配
      while (gen.length > 0) {
        let succ = gen.pop();
        for (let pred of preds) if (matchFunc(pred, succ)){
          succ.move(pred);
        }
      }
  
      gens.push(preds);
    }

    gen.trav(entry => {
      entry.getPath();
    })

    // 返回祖先一代。
    gen.attr.form = 'NESTED';

    return gen;
  }

  trav(func=e=>e, dir='PRE'){
    
    if (!['POST', 'PRE'].includes(dir)){
      throw Error('Cascade.trav: direction must be either POST or PRE');
    }

    for (let [index, curr] of this.entries()) if (curr) {
      (dir === 'PRE') && func(curr, index);
      try{
        curr.succ && curr.succ.trav(func, dir);
      }catch {
        console.log(curr);
      }
      (dir === 'POST') && func(curr, index);
    }
  }

  // 按线索寻找Category中的某个元素。如果给定colName则按照colName，否则按照code
  // 返回值是一个list，如果给定了Path，长度和给定Path是一样的。如果未给定Path，则
  // 将Path按照code来寻找，以code所能匹配的最深的一级结束。
  // 
  // 如果在某一级按照当前path未能找到对应元素，那么从那一级之后的元素均为undefined。
  findEntry({code: markCode, path}, colName) {
    
    const pathElems = new List();
    const currList = this;

    if (colName !== undefined) {
      while(path.length > 0) {
        const currElem = currList.find(({[col]: val}) => val === path.pop());
        pathElems.push(currElem);
        currList = currElem?.succ ?? [];
      }
    } else {
      while(currList !== undefined) {
        const currElem = currList.find(({code}) => markCode.startsWith(code));
        pathElems.push(currElem);
        currList = currElem?.succ;
      }
    }

    return pathElems;
  }

  toDict(colName) {

    const func = colName === undefined
    ? ({curr:{code}}) => code
    : typeof colName === 'string'
    ? ({[colName]: col}) => col
    : colName

    return this.flat().map(elem => {
      const key = elem.path().map(func).join('/');
      return [key, elem];
    })
  }

  mergeFrom(sourceData, {type, rules, action}={}) {

    if (type === 'indirect') {

      if (rules && rules.constructor === Rule){
        return rules.match(sourceData);
      }

    } else {

      const sources = sourceData.attr.form === 'NESTED' ? sourceData.flat() : sourceData;
      const targets = this.attr.form === 'NESTED' ? this.flat() : this;
  
      let sourceKey, targetKey;
      if (rules === undefined) {
        sourceKey = 'curr.code';
        targetKey = 'curr.code';
      } else if (typeof rules === 'string') {
        sourceKey = rules;
        targetKey = rules;  
      } else {
        sourceKey = (rules.source ?? rules.key) ?? 'curr.code';
        targetKey = (rules.target ?? rules.key) ?? 'curr.code';  
      }

      const targetMap = {};
      for (let targ = targets.length - 1; targ >= 0; targ --) {
        const targElem = targets[targ];
        const targKey = propFunc(targElem, targetKey);
        targetMap[targKey] ??= targElem;
      }

      const mergeAction = typeof action === 'function'
        ? action
        : mergeMethods[action ?? 'MERGE']

      for (let sour = sources.length - 1; sour >= 0; sour --) {
        const sourElem = sources[sour];
        const sourKey = propFunc(sourElem, sourceKey);
        const targElem = targetMap[sourKey];
        targElem && mergeAction(targElem, sourElem);
      }

    }
  }
}