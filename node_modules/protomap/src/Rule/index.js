import mergeMethods from '../merge-methods';
import {propPath} from '../prop-func';
import {Cascade} from '../Cascade';

function conform(orig='', patt) {

  const origList = orig.split('/');
  const pattList = patt.split('/');

  let res = true;
  while (pattList.length > 0 && res) {

    // When original path has been consumed up. It's guranteed to
    // be false.
    if (origList.length === 0) {
      res = false;
      break;
    }

    const origSeg = origList.shift();
    const pattSeg = pattList.shift();

    // If a pattern segment found to be an asterisk (*), means we have
    // finished all previous matching, and the * matches all remaining
    // parts of the original path. We stop here, and all posiible rest
    // part of pattern will be omitted.

    if (pattSeg === '*') {
      res = true;
      break;
    }

    // else we proceed to a normal matching. if the segments at same
    // position doesn't match, then a false result will be formed, and
    // the loop will stop.

    res = origSeg === pattSeg;
  }

  return res;
}

// 默认的搬运方法
const carryMethods = {
  SELF: rec => [rec],
  NEXT: ({succ}) => succ,
  REST: ({succ}) => succ.flat(),
  LAST: ({succ}) => succ.flat().filter(({succ}) => succ.length === 0),
  CURR_CATE: ({succ}) => {
    const list = new Cascade();
    succ.trav(rec => {
      if (rec.attr.level === 'CURR_CATE') list.push(rec);
    })
    return list;
  },
  DEST_CATE: ({succ}) => {
    const list = new Cascade();
    succ.trav(rec => {
      if (rec.attr.level === 'DEST_CATE') list.push(rec);
    })
    console.log('DEST_CATES', list);
    return list;
  },
  DIRECTION: ({succ}) => {
    const list = new Cascade();
    succ.trav(rec => {
      if (rec.attr.level === 'DIRECTION') list.push(rec);
    })
    console.log('DIRECTION', list);
    return list;
  }
}

// 默认的匹配方法
const castMethods = {
  TRUE: () => true,
  '*':  () => true,
  FALSE:() => false,
  '!':  () => false,
  '^>': (val, patt) => val.startsWith(patt),
  '^@': (val, patt) => patt.startsWith(val),
  '<$': (val, patt) => val.endsWith(patt),
  '@$': (val, patt) => patt.endsWith(val),
  '~':  (val, patt) => val.includes(patt),
  '@':  (val, patt) => patt.includes(val),
  '=':  (val, patt) => patt === val,
  '~/': (val, patt) => conform(val, patt),
}

const merge = (action='MERGE', rec, dest) => {

  if (typeof action === 'string') {

    mergeMethods[action](dest, rec);
    return [rec];
  } else if (typeof action === 'function') {
    action(dest, rec);
    return [rec];
  } else {
    throw Error('Invalid merging method');
  }
}

const carry = (action='SELF', rec) => {

  if (typeof action === 'string') {
    return carryMethods[action](rec);
  } else if (typeof action === 'function') {
    return action(rec);
  } else {
    throw Error('Invalid carrying method');
  }
}

/**
 * Rule Class
 * ----------
 * When the destination is givne, all other specficiation of next level
 * will be invalidated. The destination should be always associated to
 * an actual record.
 */
export class Rule {
  constructor({prop='curr.name', patt, cast, cand, action, dest}={}) {
    
    this.prop = prop;
    this.patt = patt;
    this.cast = cast;
    this.overProp = undefined;
    this.overCast = undefined;
    this.overSucc = undefined;

    this.succ = cand ?? new Cascade();
    this.pred = undefined;

    if (typeof dest === 'string') {
      this.dest = {name: dest};
    } else if (typeof dest === 'object' && dest.object) {
      this.dest = dest;
    } else {
      this.dest = {};
    }

    this.action = action ?? (this.succ.length === 0 ? 'MERGE' : 'SELF');
    this.attr = {};
  }

  move(dest) {
    this.pred = dest;
    dest.succ.push(this);
  }

  match(list, {overProp, overCast}={}) {

    // # MATCH的工作原理
    // 
    // 1. 发起match动作的是top-level rule (TLR)，从原理上TLR不拒绝任何
    //    被匹配对象，而是送往下一层的规则进行后续匹配。
    // 
    // 2. 每层会通过find来找到匹配的next-level rule (NLR)，而并非进入到
    //    下一层的备选rule列表中循环查找。
    // 
    // 3. 如果当前rule没有NLR，那么会按照当前rule中指定的destination和对
    //    应的merge operation完成分配操作。
    //
    // 4. 每层rule可以指定一个carry方法，对于级联的记录可以进行展开、筛选等
    //    操作。特别需要注意的是这个carry方法apply于cast操作之前，原因仍然
    //    是每层rule并不是在匹配自己，而是在匹配下一层，因此需要在匹配之前完
    //    成NLR所接受的形式。

    const {patt, prop, cast, dest, succ, action} = this;

    for (let i = 0; i < list.length; i++) {

      const rec = list[i];

      const handledProp = overProp ?? prop ?? 'curr.name';
      const handledCast = overCast ?? cast ?? '=';

      const propVal = propPath(rec, handledProp);
      const castMethod = castMethods[handledCast];
      const castResult = castMethod(propVal, patt);

      if (!castResult) {

        // console.log(`NOT MATCHED @ [${handledProp} by (${propVal})] ${handledCast} [${patt}]`);

      } else if (!succ || succ.length === 0) {
        merge(action, rec, dest.object);
      } else for (let s = 0; s < succ.length; s++) {
        const subRule = succ[s];
        subRule.match(carry(action, rec), {overCast: this.overCast, overProp: this.overProp});
      }

    }

  }

  initDest(destList, destKey='curr.name') {
    const action = (target, source) => {
      target.dest = source;
    }
    this.succ.mergeFrom(destList, {rules:{target: 'dest', source:destKey, action}});
  }
}