import {createCascade, createRules} from '../util';

describe('rule', () => {

  const source = createCascade().nest();

  describe('directly assign to target', () => {

    const targets = createCascade().nest();
    const targetEndLevel = targets.flat().filter(({succ}) => succ.length === 0);

    const {rules: origRule, sampled} = createRules(source, targets, {ratio:0.2});
    
    console.log(origRule.succ);
    origRule.match(source.flat());


    test('each of the destination record corresponds to the rule pattern', () => {
      for (let {dest} of origRule.succ) {
        expect(targetEndLevel.includes(dest.object)).toBe(true);
      }
    });

    test('all sampled source records should be moved to targets',() => {
      expect([].concat(...targetEndLevel.map(({succ}) => succ)).length).toBe(sampled.length);
    }) 

  })

  describe('indirectly assign', () => {

    const targets = createCascade().nest();
    const targetEndLevel = targets.flat().filter(({succ}) => succ.length === 0);

    const {rules: origRule, sampled, rest} = createRules(source, targets, {attempts: 15});

    origRule.match(source.flat());
    
    test('all sampled source records should be moved to targets',() => {
      expect([].concat(...targetEndLevel.map(({succ}) => succ)).length).toBe(sampled.length);
    }) 

  })
})