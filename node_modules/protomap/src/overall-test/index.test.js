import {Cascade} from '../Cascade';
import {Voucher} from '../Voucher';
import {Balance} from '../Balance';

import {randomSelect, createEntryData, createCateList, createCascade, randomLenArray, formVoucher} from '../util';

const createItemFromCascade = (range, base) => (entry) => {
  return randomLenArray(range, base).map(() => createEntryData(entry, {item:true}))
}

describe('基本覆盖测试-基于随机生成的帐套', () => {

  let cate = createCascade({attempts: 100}).nest();
  let cateEnds = cate.flat().filter(({succ}) => succ.length === 0);

  let item;
  let itemCate;
  let voucher;
  let itemVoucher = new Cascade();
  let mergedCateEnds;
  let gatheredByCate;
  let decompVoucherEntries;

  // 依据随机生成的科目设置形成对应的凭证表
  // 
  // 凭证表中所有分录的发生科目必须是余额表中的末级科目。
  // 
  // 凭证表的形成详见formVoucher。形成一个凭证需要先获得科目列表。在科目列表上随机选择若干个科目，然
  // 后在这些科目中重复若干次随机挑选两个科目，用同样的数额分别记一笔借和一笔贷。然后将所有发生科目对
  // 方科目完全相同的分录汇集到一起，并对发生额求和，然后借贷方均减去重合部分，也就是
  // 
  // [dr, cr] = [dr - min(dr, cr), cr - min(dr, cr)]
  // 
  // 从而确保每条分录的发生额只有借方或贷方。
  // 形成的凭证应当保证：
  // 1. 每个凭证有唯一的ID，任意凭证之间没有重复
  // 2. 每个凭证行有唯一的ID，不同凭证下的任意凭证行没有重复
  // 3. 每个凭证的借贷方总额相等
  // 
  // 主要是验证这个用于生成测试数据集的工具（就是formVoucher）是否正确。


  test('生成的凭证应当具有唯一ID', () => {

    voucher = randomLenArray(100, 500, Cascade).map((_, i) => {
      return Voucher.from(formVoucher(cate.flat(), {year: 2020, month: 1, voucherID:i}))
    });

    const voucherIDs = voucher.map(({voucherID}) => voucherID);
    expect([...new Set(voucherIDs)].length).toBe(voucherIDs.length);
  })

  test('每个凭证的分录应当具有唯一ID', () => {
    const entryIDs = (new Cascade()).concat(...voucher.map(({succ}) => succ)).map(({voucherID}) => voucherID);
    console.log(entryIDs.slice(0, 10));
    expect([...new Set(entryIDs)].length).toBe(entryIDs.length);
  })

  test('凭证借贷额应当相等', () => {
    expect(voucher.every(({accrual:{cr, dr}}) => Math.abs(cr - dr) < 1e-4));
  })


  // 生成核算科目
  // 
  // 核算科目表通过总科目表的所有末级科目生成。我们通过item来模拟从excel表中读取的数据，每个末级科目下
  // 形成5到15个明细科目。item中应当包含末级科目名称及编号，以及明细科目名称及编号。明细科目应当保证其
  // 在同一末级科目下的明细科目拥有唯一ID，同时在总的明细科目表中ID不重复。构造明细科目代码是将明细科目
  // 代码及所属的末级科目编码用'.'连接，也就是
  // 
  // `${code}.${itemCode}`
  // 
  // 在我们的测试环境中，我们为每个末级科目都生成了明细科目，因此：
  // 1. 所有明细科目映射到其所属的末级科目的不重复的ID数量，同末级科目的数量应当是相等的。

  test('依据末级科目应当形成核算科目，且核算科目编码应当不重复', () => {
    item = new Cascade().concat(...cateEnds.map(createItemFromCascade(10, 5)));
    itemCate = Cascade.from(item.map(item => new Balance(item)));

    expect(itemCate.every(({curr:{code}}) => code.includes('.'))).toBe(true);
    expect([...new Set(item.map(({code, itemCode}) => `${code}.${itemCode}`))].length).toBe(item.length);
  })

  test('所形成的核算科目的所属上级科目数量和末级科目数量应当相等', () => {
    const itemCateGrip = itemCate.grip(({curr:{code}}) => code.split('.')[0]).keys();
    expect(itemCateGrip.length).toBe(cateEnds.length);  
  })

  // 生成核算科目的序时帐
  // 
  // 如果在总序时帐中，某凭证某分录的发生科目下设有核算项目，那么此分录必须属于其发生科目下的某个核算项目。
  // 由于我们在形成核算科目时，在所有的末级科目下都形成了核算科目，因此序时帐中所有的分录其实都属于某个核
  // 算项目。

  test('应当生成明细科目序时账', () => {

    const itemMap = item.grip('code');
  
    for (let {succ} of voucher) {
      itemVoucher.push(...succ.map(entry => {
        const {curr:{code, name}, ...restEntry} = entry;
        const {itemCode, itemName} = itemMap.get(code).randomSelect();
        return new Voucher({...restEntry, code, name, itemCode, itemName});
      }))
    }  


    expect(itemVoucher.every(({curr:{code}}) => code.includes('.')));
  })

  // 将明细科目融合至总科目余额表
  // 
  // 依据明细科目的ID融合到总科目余额表，分配的动作是将明细科目加入至末级科目的下层。
  // 1. 由于每个总科目的ID是唯一的，因此融合目标的列表的长度和末级科目的长度是相等的。这样确保所有的
  //    末级科目都被分配了明细科目。
  // 2. 每个末级科目下明细科目的总和，和明细科目的列表长度是相等的，这样确保所有的明细科目都**被分配
  //    到了**某个末级科目。

  test('融合后明细科目进入了之前的末级科目', () => {

    const rules = {
      source: elem => elem.curr.code.split('.')[0],
      target: 'curr.code',
    }

    cate.mergeFrom(itemCate, {rules, action: 'CONS'});

    mergedCateEnds = cate.flat().filter(({succ}) => succ.length === 0);

    expect(cateEnds.every(({succ}) => succ.length > 0)).toBe(true);
  })

  test('每个明细科目的上级科目的科目编码是明细科目本身编码的前半部分', () => {
    expect(itemCate.every(({pred, curr}) => pred.curr.code === curr.code.split('.')[0])).toBe(true);
  })

  test('新的末级科目的数量应当和明细科目数量相等', () => {
    expect(mergedCateEnds.length).toBe(itemCate.length);
  })

  test('明细科目的数量应与之前的末级科目的所有子级科目数量之和相等', () => {
    expect(itemCate.length).toBe(cateEnds.reduce((acc, {succ}) => acc + succ.length, 0));
  })

  // 将明细序时帐融合至总序时帐
  // 
  // 依据分录ID的对应关系进行分配，分配的动作是将对应的明细序时帐分录的明细科目信息（代码、名称）覆盖
  // 原始的科目信息。验证方法：
  // 1. 融合后的目标数量和序时帐总分录数量，以及明细序时帐的分录数量相等。
  // 2. 因为每个原末级科目下都有明细科目，因此所有总序时帐分录均已覆盖。


  test('当前序时账中所有分录应当均已替换为明细科目编码', () => {

    // mergeFrom是只有Cascade才有的方法，原先的voucher是Array of Voucher，因此需要先转化。
    const voucherFlatten = new Cascade();
    for (let {succ} of voucher) {
      voucherFlatten.push(...succ);
    }

    voucherFlatten.mergeFrom(itemVoucher, {rules: 'voucherID'});

    for (let {curr:{code}} of voucherFlatten) {
      expect(code.includes('.')).toBe(true);
    }
  })


  test('所有的序时账的己方和对方科目都以替换为科目余额表中的对应Ident', () => {

    const mergedCateEndMap = mergedCateEnds.grip('curr.code');

    // 先为末级科目的条目做个标记
    for (let cateEndEntry of mergedCateEnds) {
      const {curr} = cateEndEntry;
      curr.setRef(cateEndEntry);
      curr.mark = true;
    }

    // 然后将末级科目的curr写入序时账的curr和dest
    for (let v of voucher) {
      v.decomposeNorm();

      const {succ: entries} = v;

      for (let entry of entries) {
        const {curr: {code: currCode}, dest: {code: destCode}} = entry;
        const [{curr}] = mergedCateEndMap.get(currCode);
        const [{curr: dest}] = mergedCateEndMap.get(destCode);
        Object.assign(entry, {curr, dest})
      }

    }

    for (let {succ} of voucher) {
      expect(succ.every(({curr, dest}) => curr.mark && dest.mark));
    }
  })

  test('已分解的凭证中每个分录都满足借贷相等，并且先后两条的科目可以对应', () => {
    for (let {succ} of voucher) {
      const pairs = succ.partition(2);

      expect(pairs.every(([{accrual:{dr}}, {accrual:{cr}}]) => Math.abs(dr - cr) < 1e-4)).toBe(true);
      expect(pairs.every(([{curr}, {dest}]) => curr === dest)).toBe(true);
      expect(pairs.every(([{dest}, {curr}]) => curr === dest)).toBe(true);
    }
  })

  test('将序时账拆分，并按发生科目及对方科目重新分类', () => {

    decompVoucherEntries = new Cascade();
    for (let {succ} of voucher) {
      decompVoucherEntries.push(...succ);
    }

    gatheredByCate = decompVoucherEntries.grip('curr.code')
    .grap(([, entries]) => {
      const gatheredByDest = entries.grip('dest.code').grap(([, entries]) => Voucher.from(entries));
      return Voucher.from(gatheredByDest);
    });
      
    gatheredByCate = new Cascade().concat(...gatheredByCate);

    for (let currGroup of gatheredByCate) {
      expect(new Cascade().concat(...currGroup.succ.map(({succ}) => succ)).every(({curr}) => curr === currGroup.curr));
      for (let destGroup of currGroup.succ) {
        expect(destGroup.succ.every(({dest}) => dest === destGroup.dest));
      }
    }
  })

  test('将归类后的序时账归入对应的科目', () => {

    cate.mergeFrom(gatheredByCate, {action: 'CONS'});

    for (let {succ} of gatheredByCate) {
      expect(succ.every(elem => elem.pred.succ.length === succ.length));
    }
  })

  test('应当能通过分录所属的己方和对方科目重新找到这个分录', () => {

    const entry = randomSelect(decompVoucherEntries);
    const entryCate = entry.curr.ref;
    console.log(entry.curr.ref === entry);

    let entrySubs = [].concat(...entryCate.succ.map(({succ}) => succ));
    entrySubs = [].concat(...entrySubs.map(({succ}) => succ));
    expect(entrySubs).toContain(entry);

    const entryDestCate = entry.dest.ref;

    let entryDestSubs = [].concat(...entryDestCate.succ.map(({succ}) => succ));
    entryDestSubs = [].concat(...entryDestSubs.map(({succ}) => succ));
    expect(entryDestSubs.find(({accrual}) => accrual.cr === entry.accrual.dr && accrual.dr === entry.accrual.cr)).not.toBeUndefined();

    // for (let entry of decompVoucherEntries) {

    //   // 先看entry所属的末级科目是否已经包含了它本身
    //   console.log(n)
    //   // const dest = entry.dest.ref;
    //   // const {cr, dr} = entry.accrual;
    //   // const destCurrGroup = dest.succ.find(({dest}) => dest.code === entry.curr.code);
    //   // expect(destCurrGroup).not.toBeUndefined();
    //   // expect(destCurrGroup.succ.find(({accrual}) => accrual.cr === dr && accrual.dr === cr));
    // }
  })



      // for (let {succ} of gatheredByCurr) {
      //   expect(succ.length > 0).toBe(true);

      //   for (let {succ: entries} of succ) for (let {dest, curr} of entries) {

      //     expect(newCateEnd.includes(dest.ref))
      //     expect(dest.ref.succ.find(({dest}) => dest.code === curr.code)).not.toBeUndefined();

      //   }

      // }
    // })
})
