import {Balance} from '../Balance';
import { Voucher } from '../Voucher';
import { Cascade } from '../Cascade';
import { Entry } from '../Entry';
import { Rule } from '../Rule';

export function isInherited (desc, ances) {
  return desc === ances || desc.prototype instanceof ances
}

/**
 * ## to2
 * 广泛应用的将浮点数化为取两位小数的定点数
 * @param {*} number 
 */
export const to2 = (number) => {
  return parseFloat(number.toFixed(2))
};

/**
 * ## randomString
 * 按给定长度形成一个包含字母与数字的随机字符串
 * @param {number} len 
 */
export const randomString = (len) => {
  return Math.random().toString(35).slice(2, 2+len);
}

/**
 * ## randomIndex
 * 从列表中随机选择一个元素的index
 * @param {Array} list 
 */
export const randomIndex = (list, {min=0, max=list.length}={}) => {

  const index = list.length * Math.random()

  return Math.floor(Math.min(Math.max(index, min), max < 0 ? list.length - 1 + max : max));
}

/**
 * ## randomSelect
 * 从列表中随机选择若干不重复的元素
 * @param {Array} list 列表
 * @param {number} number 索要选择的元素数量。
 * ----
 * - 如果number为0到1之间的实数，则取其与列表长度乘积之floor；如果为大于1的实数，则为实际的数量；如果多于list的长度，则取list的长度。
 */
export const randomSelect = (list, number = 0, {Cons=Array, remaining=false}={}) => {

  if (number === 0 || number === 1) {
    return list[randomIndex(list)];
  }

  const actualNumber = number > 0 && number < 1
    ? Math.floor(list.length * number)
    : Math.min(number, list.length)

  const copy = list.slice();
  const res = new Cons();
  for (let i = 0; i < actualNumber; i++) {
    const [elem] = copy.splice(randomIndex(copy), 1);
    res.push(elem);
  }

  if (remaining) {
    return {selected: res, rest: copy};
  }

  return res;
}

export const excerpt = (list, cond, Cons=Array) => {
  const result = new Cons();
  for (let i = 0; i < list.length; i++) {
    if (cond(list[i])) {
      result.push(list.splice(i, 1)[0]);
      i--;
    }
  }
  return result;
}

/**
 * ## createEntryData
 * ---
 * 模拟账套的一条记录，科目余额或发生额
 * 
 * 1. 可以用于单独生成凭证行，此时只会用到借贷方发生额
 * 2. 可以用于生成一行科目余额，此时需要指明期初期末借贷方向，以及类别
 * 3. 描述期初期末的方式可以在dirType中设定。
 * 
 * @param {Object} entry 一条记录 
 * @param {Object} opts 选项 
 */

export const createEntryData = ({curr, code, name, itemCode, itemName, destCode, destName}={}, {dir='dr', dirType='single', item=false}={}) => {

  const cr = Math.random() * 100;
  const dr = Math.random() * 100;

  let balance;
  switch(dirType) {
    case 'direction':
      const opening = Math.random() * 100;
      const closing = to2(opening + (dir === 'dr' ? to2(dr - cr) : to2(cr - dr)));
      balance = {
        opening,
        closing,
        direction: dir
      };
      break;
    default:
      const [openingCr, openingDr] = dir === 'cr' ? [to2(Math.random() * 100), 0] : [0, to2(Math.random() * 100)];
      const [closingCr, closingDr] = [to2(openingCr + cr), to2(openingDr + dr)];
      balance = {
        openingCr, openingDr,
        closingCr, closingDr
      };
  }


  return {
    code: (curr?.code ?? code) ?? randomString(4),
    name: (curr?.name ?? name) ?? randomString(24),
    itemCode: itemCode ?? (item ? randomString(4) : undefined),
    itemName: itemName ?? (item ? randomString(24) : undefined),
    destCode: destCode ?? randomString(4),
    destName: destName ?? randomString(24),
    cr,
    dr,
    ...balance
  }
}

/**
 * ## createEntry
 * ---
 * 生成一条随机的Entry
 * 
 * @param {string} parentCode 上级科目的科目编码
 * @param {Function} EntryCons 构造一条entry的constructor
 * 
 */
export const createEntry = (parentCode, {EntryCons=Entry}={}) => {

  const cateSpec = {
    code: `${parentCode}${randomString(2)}`,
    name: randomString(24)
  };

  const entry = new EntryCons({...createEntryData(), ...cateSpec}, {ListCons: Cascade})
  return entry;
}

/**
 * createCascadeEntries
 * ---
 * 生成一个级联列表
 * 
 * @param {*} opts 参数
 * * attempts : 测试数量
 */
export const createCascadeEntries = ({attempts=100, EntryCons=Balance}={}) => {
  let counter = attempts;
  let cateList = [];

  while(counter > 0) {

    if (cateList.length === 0) {
      cateList.push(createEntry('', {EntryCons}));  
    }
    const {curr:{code}} = randomSelect(cateList);
    const newEntry = createEntry(code, {EntryCons});
    if (!cateList.map(({curr:{code}}) => code).includes(newEntry.curr.code)) {
      cateList.push(newEntry);
    }

    counter --;
  }

  cateList.shift()
  return cateList;
}

export const createCascade = ({attempts=100}={}) => {
  const cateList = createCascadeEntries({attempts});
  return Cascade.from(cateList);
}

export const randomLenArray = (len, base=0, ListCons=Array) => {
  return new ListCons(...Array(Math.floor(Math.random() * len + base)))
}

export const formVoucher = (categories, {year, month, voucherID}={}) => {

  const voucherProp = {
    year:  year ?? 2000 + Math.floor(Math.random() * 20),
    month: month ?? Math.ceil(Math.random() * 12),
    voucherID: voucherID ?? Math.floor(Math.random() * 20),
    billDate: new Date(),
    desc: 'yet another fake voucher',
  }

  const cateEnds = categories.filter(({succ}) => succ.length === 0).map(({curr:{code}}) => code);

  let selectedCates = [... new Set(randomSelect(cateEnds, 20))];

  let counter = Math.floor(Math.random() * 100) + 1;

  let entries = new Cascade();
  while (counter > 0) {

    const accrual = to2(Math.random() * 100);
    const [head, tail] = randomSelect(selectedCates, 2);

    entries.push(new Entry({code: head, dr: accrual}));
    entries.push(new Entry({code: tail, cr: accrual}));

    counter --;
  }

  // console.log(entries.map(({accrual}) => accrual).reduce((acc, elem) => acc.add(elem), new Accrual()));

  entries = entries.grip(({curr:{code}}) => code)
    .grap(([, grouped]) => grouped.reduce((acc, elem) => {
      acc.accrual.add(elem.accrual);
      return acc
    }))
    .map((elem, index) => {
      elem.accrual.net();
      return new Voucher({...elem, ...voucherProp, lineID: index + 1});
    })

  return entries;
}

export const createRules = (sources, targets, {ratio=0.8, attempts}={}) => {

  const targetEndLevel = targets.flat().filter(({succ}) => succ.length === 0);

  const sourceFlatten = sources.flat();
  const {selected: samples, rest} = randomSelect(sourceFlatten, ratio, {Cons: Cascade, remaining: true});
  samples.sort(({path: a}, {path: b}) => a < b ? -1 : a > b ? 1 : 0);

  const subRules = samples.map(sample => new Rule({ 
    patt: sample.path,
    prop: 'path',
    cast: '=',
    dest: {name: 'dest', object: randomSelect(targetEndLevel)},
    action: (target, source) => {
      // console.log('MOVE', source, 'TO', target);
      source.move(target);
    }
  }))

  if (attempts > 0) {

    const pathSegs = samples.map(({path}) => path.split('/'));
    const pathMaxDepth = Math.max(...pathSegs.map( p => p.length));
  
    const padArray = (len, char) => Array(len).fill(char);
  
    const padPath = (path, len, char) => {
      const segs = path.split('/');
      return len > segs.length
        ? segs.concat(padArray(len - segs.length, char)).join('/')
        : path;
    } 
  
    for (let i = 0; i < attempts; i++) {
  
      const pathLimit = Math.floor(Math.random() * pathMaxDepth);
  
      const selectedPath = subRules
        .grip(({patt}) => padPath(patt, pathLimit, '$$$'))
        .keys()
        .randomSelect()
        .split('/');
      
      const prefix = selectedPath
        .slice(0, randomIndex(selectedPath, {min: 1}))
        .join('/');

      if (prefix.includes('$$$')) continue;

      const newRule = new Rule({
        patt: `${prefix}/*`,
        prop: 'path',
        cast: '~/',
        cand: excerpt(subRules, ({patt}) => patt.startsWith(prefix) && !patt.endsWith(prefix))
      });

      subRules.push(newRule);
    }
  
  }

  return {
    sampled: samples,
    rest,
    rules: new Rule({cast:'*', cand: subRules})
  };
}