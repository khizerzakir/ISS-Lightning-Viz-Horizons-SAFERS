import {List} from '../List';
import {Accrual} from '../Accrual';
import Identity from '../Identity'

export class Entry {

  constructor(entry={}, {ListCons=List, emptyAccrual=false, emptyIdentity=false}={}) {

    const {curr, code, name, itemCode, itemName, dest, destCode, destName, accrual, cr, dr, attr, ...restAttr} = entry;
    
    this.curr = emptyIdentity
    ? new Identity({code:'NONE', name: 'NONE'})
    : curr ?? new Identity({code, name, itemCode, itemName});
    
    this.dest = dest ?? new Identity({code: destCode, name: destName});

    this.accrual = emptyAccrual
    ? new Accrual({cr: 0, dr: 0})
    : accrual?.copy() ?? new Accrual({cr, dr});

    this.attr = JSON.parse(JSON.stringify(attr ?? {type: 'RAW', ...restAttr}));

    this.succ = new ListCons();
    this.pred = undefined;
    this.path;
  }

  copy(opts={}) {
    const Cons = this.constructor;
    return new Cons(this, opts);
  }

  getPath(){
    const paths = [];
    for (let curr = this; curr; curr = curr.pred) {
      paths.push(curr);
    }
    paths.reverse();
    this.path = paths.map(({curr:{name}}) => name).join('/');
    return paths;
  }
  
  move(destEntry, {byPushProto=false, pushSide='HEAD'}={}) {
    const self = byPushProto ? this.pushProto() : this;
    
    const method = {
      HEAD: 'unshift',
      TAIL: 'push'
    }[pushSide];

    destEntry.succ[method](self);
    self.pred = destEntry;
    self.getPath();

    delete destEntry.attr.isDetailed;
  }

  pushProto() {
    const self = Object.create(this);
    const SuccCons = this.succ.constructor;
    self.pred = undefined;
    self.succ = new SuccCons();
    return self;
  }

  popProto() {
    return this.__proto__;
  }

  flatProto() {
    const flat = new Entry();
    for (let prop in flat) flat[prop] = this[prop];
    return flat;
  }
}