const {List} = require('.');
const {createCascade, createEntry, randomIndex, createEntryData} = require('../util')
  
describe('list', () => {

  const raw = [...Array(100)].map(e => createEntry());
  const list = List.from(raw);

  const cates = createCascade();
  const flat = cates.nest().flat();
  const rawFlat = flat.map(({curr}) => curr);

  test('create', () => {
    expect(list instanceof List).toBe(true);
  })

  test('orderBy', () => {
    const rawNames = raw
      .sort(({code: cPrev}, {code: cNext}) => cPrev < cNext ? -1 : cPrev > cNext ? 1 : 0)
      .map(({name}) => name);
    const listNames = list
      .orderBy(({curr:{code}}) => code)
      .map(({name}) => name);

    expect([...listNames]).toEqual(rawNames);

    const rawLengths = rawFlat.sort(({code: cPrev}, {code: cNext}) => cPrev.length - cNext.length).map(({name}) => name);
    const flatLengths = flat.orderBy(({curr:{code}}) => code.length).map(({curr:{name}}) => name);

    expect([...flatLengths]).toEqual([...rawLengths]);
  })

  test('grip', () => {
    const raw = List.from([...Array(10)].map(e => createEntryData()));
    const gripped = raw.grip('code');

    expect(gripped.cons).toBe(List);
    expect(gripped.keys().length).toBe(10);
  })

  test('partition', () => {
    const list = List.from(raw);
    const partitioned = list.partition(7);
    expect(partitioned.length).toBe(15);
    expect(partitioned.last().length).toBe(2);
  })

  test('insert', () => {
    const newEntry = createEntry();

    const list = List.from([...Array(100)].map(e => createEntry()));

    const index = randomIndex(list);

    list.insert(newEntry, index);

    expect(list[index]).toBe(newEntry);

  })

  test('remove', () => {
    const list = List.from([...Array(100)].map(e => createEntry()));

    const index = randomIndex(list);

    const elem = list[index];

    list.remove(index);

    expect(list).not.toContain(elem);
  })

  test('move-back', () => {
    const list = List.from([...Array(100)].map(e => createEntry()));

    const index = randomIndex(list);

    console.log(index, 'move-back');

    const [prev, next] = [list[index - 1], list[index]];

    list.moveBack(index);

    expect(list[index]).toBe(prev)
    expect(list[index - 1]).toBe(next);
  })
})
