import {propFunc} from '../prop-func';
import {Group} from '../Group';

const randomIndex = (list, {min=0, max=list.length}={}) => {

  const index = list.length * Math.random()

  return Math.floor(Math.min(Math.max(index, min), max < 0 ? list.length - 1 + max : max));
}

const randomSelect = (list, number = 0, {Cons=Array, remaining=false}={}) => {

  if (number === 0 || number === 1) {
    return list[randomIndex(list)];
  }

  const actualNumber = number > 0 && number < 1
    ? Math.floor(list.length * number)
    : Math.min(number, list.length)

  const copy = list.slice();
  const res = new Cons();
  for (let i = 0; i < actualNumber; i++) {
    const [elem] = copy.splice(randomIndex(copy), 1);
    res.push(elem);
  }

  if (remaining) {
    return {selected: res, rest: copy};
  }

  return res;
}



export class List extends Array {
  constructor(...args) {
      super(...args);
    this.attr = {};
  }

  last() {
    return this[this.length - 1];
  }

  orderBy(key) {

    if (key === undefined) {
      throw Error('List.orderBy: key not provided')
    }

    this.sort((prev, next) => {
      const prevVal = propFunc(prev, key),
            nextVal = propFunc(next, key);

      return prevVal > nextVal ? 1 : prevVal < nextVal ? -1 : 0
    })

    return this;
  }

  grip(key){

    const Container = this.constructor;

    let group = {};
  
    if (key === undefined) {
      throw Error('List.orderBy: key not provided')
    }  
  
    for (let i = 0; i < this.length; i++){
      const rec = this[i];
      const label = propFunc(rec, key);

      group[label] ??= new Container();
      group[label].push(rec);
    }

    return new Group(Container, group);
  }

  trav(func=e=>e, dir='PRE'){
    
    if (!['POST', 'PRE'].includes(dir)){
      throw {code:'INVLAID_TRAV_ORDER', from: 'List.trav'};
    }

    for (let [index, curr] of this.entries()) {
      (dir === 'PRE') && func(curr, index);
      curr?.succ?.trav(func, dir);
      (dir === 'POST') && func(curr, index);
    }
  }

  partition(num) {
    const newList = new this.constructor();
    for (let i = 0; i < this.length; i+=num) {
      newList.push(this.slice(i, i+num));
    }
    return newList;
  }

  randomSelect(number, {remaining=false}={}) {
    return randomSelect(this, number, {Cons:this.constructor, remaining});
  }

  insert(rec, index) {
    this.splice(index, 0, rec);
    return this;
  }

  remove(index) {
    this.splice(index, 1);
    return this;
  }

  moveBack(i) {
    if (i > 0) {
      [this[i], this[i-1]] = [this[i-1], this[i]];
    }
    return this;
  }

  moveFore(i) {
    if (i < this.length - 1) {
      [this[i], this[i+1]] = [this[i+1], this[i]];
    }
    return this;
  }
}
