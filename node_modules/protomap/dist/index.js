module.exports =
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 777:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Accrual": () => /* reexport */ Accrual,
  "Balance": () => /* reexport */ Balance_Balance,
  "Cascade": () => /* reexport */ Cascade_Cascade,
  "Entry": () => /* reexport */ Entry_Entry,
  "List": () => /* reexport */ List,
  "Rule": () => /* reexport */ Rule_Rule,
  "Voucher": () => /* reexport */ Voucher_Voucher
});

;// CONCATENATED MODULE: ./src/merge-methods.js
// 默认的记录融合方法
const mergeMethods = {
  MERGE: (target, source) => {
    Object.assign(target, source);
  },
  CONS: (target, source) => {
    source.move(target);
  },
  CONS_SUCC: (target, source) => {
    target.succ = source.succ;
  },
  CONS_CURR_CATE: (target, source) => {
    source.succ.trav(rec => {
      rec.attr.level === 'CURR_CATE' && rec.move(target);
    });
  },
  CONS_DEST_CATE: (target, source) => {
    source.succ.trav(rec => {
      rec.attr.level === 'DEST_CATE' && rec.move(target);
    });
  },
  MOVE: (target, source) => {
    console.log('MOVE', source, 'TO', target);
    source.move(target, {
      byPushProto: true
    });
  },
  MOVE_SUCC: (target, {
    succ
  }) => {
    for (let i = 0; i < succ.length; i++) {
      succ[i].move(target, {
        byPushProto: true
      });
    }
  },
  MOVE_CURR_CATE: (target, source) => {
    source.succ.trav(rec => {
      rec.attr.level === 'CURR_CATE' && rec.move(target, {
        byPushProto: true
      });
    });
  },
  MOVE_DEST_CATE: (target, source) => {
    source.succ.trav(rec => {
      rec.attr.level === 'DEST_CATE' && rec.move(target, {
        byPushProto: true
      });
    });
  }
};
/* harmony default export */ const merge_methods = (mergeMethods);
;// CONCATENATED MODULE: ./src/prop-func.js
const propPath = (rec, propPath) => {
  if (!propPath.includes('.')) {
    return rec[propPath];
  } else {
    const path = propPath.split('.').reverse();
    let curr = rec;

    while (curr && path.length > 0) {
      var _curr;

      curr = (_curr = curr) === null || _curr === void 0 ? void 0 : _curr[path.pop()];
    }

    return curr;
  }
};
const propFunc = (rec, propSpec = '') => {
  if (typeof propSpec === 'function') {
    return propSpec(rec);
  } else if (typeof propSpec === 'string') {
    return propPath(rec, propSpec);
  } else {
    return undefined;
  }
};
;// CONCATENATED MODULE: ./src/Group/index.js
class Group {
  constructor(Container, dict) {
    this.cons = Container;
    this.dict = dict;
  }

  map(func) {
    const defaultFunc = ([k, v]) => [k, v];

    return new Group(this.cons, Object.fromEntries(Object.entries(this.dict).map(func !== null && func !== void 0 ? func : defaultFunc)));
  }

  grap(func) {
    const Cons = this.cons;

    const defaultFunc = ([, v]) => v;

    return new Cons(...Object.entries(this.dict).map(func !== null && func !== void 0 ? func : defaultFunc));
  }

  keys() {
    const Cons = this.cons;
    return new Cons(...Object.keys(this.dict));
  }

  get(key) {
    return this.dict[key];
  }

}
;// CONCATENATED MODULE: ./src/List/index.js



const randomIndex = (list, {
  min = 0,
  max = list.length
} = {}) => {
  const index = list.length * Math.random();
  return Math.floor(Math.min(Math.max(index, min), max < 0 ? list.length - 1 + max : max));
};

const randomSelect = (list, number = 0, {
  Cons = Array,
  remaining = false
} = {}) => {
  if (number === 0 || number === 1) {
    return list[randomIndex(list)];
  }

  const actualNumber = number > 0 && number < 1 ? Math.floor(list.length * number) : Math.min(number, list.length);
  const copy = list.slice();
  const res = new Cons();

  for (let i = 0; i < actualNumber; i++) {
    const [elem] = copy.splice(randomIndex(copy), 1);
    res.push(elem);
  }

  if (remaining) {
    return {
      selected: res,
      rest: copy
    };
  }

  return res;
};

class List extends Array {
  constructor(...args) {
    super(...args);
    this.attr = {};
  }

  last() {
    return this[this.length - 1];
  }

  orderBy(key) {
    if (key === undefined) {
      throw Error('List.orderBy: key not provided');
    }

    this.sort((prev, next) => {
      const prevVal = propFunc(prev, key),
            nextVal = propFunc(next, key);
      return prevVal > nextVal ? 1 : prevVal < nextVal ? -1 : 0;
    });
    return this;
  }

  grip(key) {
    const Container = this.constructor;
    let group = {};

    if (key === undefined) {
      throw Error('List.orderBy: key not provided');
    }

    for (let i = 0; i < this.length; i++) {
      var _group$label;

      const rec = this[i];
      const label = propFunc(rec, key);
      (_group$label = group[label]) !== null && _group$label !== void 0 ? _group$label : group[label] = new Container();
      group[label].push(rec);
    }

    return new Group(Container, group);
  }

  trav(func = e => e, dir = 'PRE') {
    if (!['POST', 'PRE'].includes(dir)) {
      throw {
        code: 'INVLAID_TRAV_ORDER',
        from: 'List.trav'
      };
    }

    for (let [index, curr] of this.entries()) {
      var _curr$succ;

      dir === 'PRE' && func(curr, index);
      curr === null || curr === void 0 ? void 0 : (_curr$succ = curr.succ) === null || _curr$succ === void 0 ? void 0 : _curr$succ.trav(func, dir);
      dir === 'POST' && func(curr, index);
    }
  }

  partition(num) {
    const newList = new this.constructor();

    for (let i = 0; i < this.length; i += num) {
      newList.push(this.slice(i, i + num));
    }

    return newList;
  }

  randomSelect(number, {
    remaining = false
  } = {}) {
    return randomSelect(this, number, {
      Cons: this.constructor,
      remaining
    });
  }

  insert(rec, index) {
    this.splice(index, 0, rec);
    return this;
  }

  remove(index) {
    this.splice(index, 1);
    return this;
  }

  moveBack(i) {
    if (i > 0) {
      [this[i], this[i - 1]] = [this[i - 1], this[i]];
    }

    return this;
  }

  moveFore(i) {
    if (i < this.length - 1) {
      [this[i], this[i + 1]] = [this[i + 1], this[i]];
    }

    return this;
  }

}
;// CONCATENATED MODULE: ./src/Accrual/index.js
function to2(number) {
  if (typeof number === 'number') {
    return parseFloat(number.toFixed(2));
  } else {
    return number;
  }
}

class Accrual {
  constructor({
    cr = 0,
    dr = 0,
    swapped = false
  } = {}) {
    this.cr = to2(cr);
    this.dr = to2(dr);
    this.swapped = swapped;
  }

  swap() {
    const {
      cr,
      dr
    } = this;

    if (cr < 0 || dr < 0) {
      this.cr = to2(-dr);
      this.dr = to2(-cr);
      this.swapped = true;
    }
  }

  unswap() {
    const {
      cr,
      dr
    } = this;

    if (this.swapped) {
      this.cr = to2(-dr);
      this.dr = to2(-cr);
      this.swapped = false;
    }
  }

  diff(dir = 0) {
    const {
      cr,
      dr
    } = this;
    return to2(dir < 0 ? cr - dr : dr - cr);
  }

  dir() {
    const {
      cr,
      dr
    } = this;

    if (dr === 0 && cr !== 0) {
      return 'cr';
    } else if (cr === 0 && dr !== 0) {
      return 'dr';
    } else {
      return 'zero';
    }
  }

  add({
    cr = 0,
    dr = 0
  } = {}) {
    this.cr = to2(this.cr + cr);
    this.dr = to2(this.dr + dr);
    return this;
  }

  net() {
    const {
      cr,
      dr
    } = this;
    const base = Math.min(cr, dr);
    this.cr = to2(cr - base);
    this.dr = to2(dr - base);
    return this;
  }

  copy() {
    return new Accrual(this);
  }

}
;// CONCATENATED MODULE: ./src/Identity/index.js
class Identity {
  constructor({
    code = '',
    name = '',
    ref,
    itemCode,
    itemName
  } = {}) {
    var _itemName$toString;

    this.code = itemCode ? `${code}.${itemCode}` : code.toString();
    this.name = (_itemName$toString = itemName === null || itemName === void 0 ? void 0 : itemName.toString()) !== null && _itemName$toString !== void 0 ? _itemName$toString : name.toString();
    this.ref = ref;
  }

  set({
    code = '',
    name = ''
  } = {}) {
    this.code = code;
    this.name = name;
  }

  setRef(ref) {
    this.ref = ref;
  }

}

/* harmony default export */ const src_Identity = (Identity);
;// CONCATENATED MODULE: ./src/Entry/index.js



class Entry_Entry {
  constructor(entry = {}, {
    ListCons = List,
    emptyAccrual = false,
    emptyIdentity = false
  } = {}) {
    var _accrual$copy;

    const {
      curr,
      code,
      name,
      itemCode,
      itemName,
      dest,
      destCode,
      destName,
      accrual,
      cr,
      dr,
      attr,
      ...restAttr
    } = entry;
    this.curr = emptyIdentity ? new src_Identity({
      code: 'NONE',
      name: 'NONE'
    }) : curr !== null && curr !== void 0 ? curr : new src_Identity({
      code,
      name,
      itemCode,
      itemName
    });
    this.dest = dest !== null && dest !== void 0 ? dest : new src_Identity({
      code: destCode,
      name: destName
    });
    this.accrual = emptyAccrual ? new Accrual({
      cr: 0,
      dr: 0
    }) : (_accrual$copy = accrual === null || accrual === void 0 ? void 0 : accrual.copy()) !== null && _accrual$copy !== void 0 ? _accrual$copy : new Accrual({
      cr,
      dr
    });
    this.attr = JSON.parse(JSON.stringify(attr !== null && attr !== void 0 ? attr : {
      type: 'RAW',
      ...restAttr
    }));
    this.succ = new ListCons();
    this.pred = undefined;
    this.path;
  }

  copy(opts = {}) {
    const Cons = this.constructor;
    return new Cons(this, opts);
  }

  getPath() {
    const paths = [];

    for (let curr = this; curr; curr = curr.pred) {
      paths.push(curr);
    }

    paths.reverse();
    this.path = paths.map(({
      curr: {
        name
      }
    }) => name).join('/');
    return paths;
  }

  move(destEntry, {
    byPushProto = false,
    pushSide = 'HEAD'
  } = {}) {
    const self = byPushProto ? this.pushProto() : this;
    const method = {
      HEAD: 'unshift',
      TAIL: 'push'
    }[pushSide];
    destEntry.succ[method](self);
    self.pred = destEntry;
    self.getPath();
    delete destEntry.attr.isDetailed;
  }

  pushProto() {
    const self = Object.create(this);
    const SuccCons = this.succ.constructor;
    self.pred = undefined;
    self.succ = new SuccCons();
    return self;
  }

  popProto() {
    return this.__proto__;
  }

  flatProto() {
    const flat = new Entry_Entry();

    for (let prop in flat) flat[prop] = this[prop];

    return flat;
  }

}
;// CONCATENATED MODULE: ./src/Balance/index.js



const accrual = (accrual, dir, {
  cr = 0,
  dr = 0
} = {}) => {
  if (accrual instanceof Accrual) {
    return accrual.copy();
  } else switch (dir) {
    case 'cr':
      return new Accrual({
        cr: accrual,
        dr: 0
      });

    case 'dr':
      return new Accrual({
        dr: accrual,
        cr: 0
      });

    default:
      return new Accrual({
        cr,
        dr
      });
  }
};

class Balance_Balance extends Entry_Entry {
  constructor({
    opening,
    closing,
    direction,
    closingDir,
    openingDr,
    openingCr,
    closingDr,
    closingCr,
    ...entry
  } = {}, opts) {
    super(entry, opts);
    this.opening = accrual(opening, direction, {
      cr: openingCr,
      dr: openingDr
    });
    this.closing = accrual(closing, direction, {
      cr: closingCr,
      dr: closingDr
    });
  }

  static from(list, {
    ListCons,
    orderKey,
    removeSucc
  } = {}) {
    if (list.some(entry => !(entry instanceof Balance_Balance))) {
      throw Error('Balance.from: 新的余额项目必须由一个余额项目列表累加而成');
    }

    if (list.every(({
      curr: {
        code
      }
    }, i, a) => code !== a[0].curr.code)) {
      throw Error('Balance.from: 试图将不同的科目累加到一起');
    }

    const balance = new Balance_Balance(list[0], {
      emptyAccrual: true,
      ListCons
    });

    if (orderKey !== undefined) {
      var _list$orderBy;

      (_list$orderBy = list.orderBy) === null || _list$orderBy === void 0 ? void 0 : _list$orderBy.call(list, orderKey);
    }

    for (let entry of list) {
      balance.add(entry, {
        isAccum: true
      });
      entry.move(balance, {
        pushSide: 'TAIL'
      });
    }

    if (removeSucc) {
      balance.succ = new ListCons();
    }

    return balance;
  }

  add(entry, {
    isAccum = false
  } = {}) {
    if (!isAccum) {
      this.opening.add(entry.opening);
    }

    this.accrual.add(entry.accrual);

    if (isAccum) {
      this.closing = entry.closing.copy();
    } else {
      this.closing.add(entry.closing);
    }
  }

  copy() {
    return new Balance_Balance(this);
  }

}
;// CONCATENATED MODULE: ./src/Voucher/alternate-deduct.js


function assignDest(morn, dusk) {
  morn.dest = dusk.curr;
  dusk.dest = morn.curr;
}

const toFixed2 = number => parseFloat(number.toFixed(2)); // mark can be either 'morn' or 'dusk' only;


const accumulate = (list, col, mark) => list.map(({
  accrual: {
    [col]: val
  }
}) => val).reduce(([last, ...rest], next) => [toFixed2(next + last), last, ...rest], [0]).reverse().map((accrual, index) => ({
  accrual,
  [mark]: index
}));

function alternateDeduct({
  list: morns,
  col: mornCol
}, {
  list: dusks,
  col: duskCol
}) {
  const mornVals = accumulate(morns, mornCol, 'morn');
  const duskVals = accumulate(dusks, duskCol, 'dusk'); // 上面两步所得到的结果，分别是借贷方发生额从0累加之后的边界值。如果把每个发生
  // 额想象成某个长度，那么n个长度会产生n+1个边界。参考篱笆和桩的问题。

  const sortedIndex = [...mornVals, ...duskVals] // 请牢记篱笆和桩的数量关系，我们将两个数组组合之后排序，显然morns和dusks原先
  // 的数值会穿插在一起，这样我们就能看到两个数组中，morns的某个桩，会落入dusks
  // 的哪两个桩之间，vice versa for dusks。
  .sort(({
    accrual: A
  }, {
    accrual: B
  }) => A - B) // 这一步操作即计算桩的穿插关系。除首尾重复的桩之外，第i个morn桩之后出现的所有
  // dusk桩都属于第i个morn桩，因此当一个dusk桩出现时，它所属的morn桩总是上一个
  // 桩所属的morn桩, vice versa for morns。在完成了桩的分配之后，我们去掉首尾
  // 两个多出来的桩。
  .reduce(([last, ...rest], {
    accrual,
    morn,
    dusk
  }) => {
    return last === undefined ? [{
      accrual,
      morn: morn !== null && morn !== void 0 ? morn : 0,
      dusk: dusk !== null && dusk !== void 0 ? dusk : 0
    }] : [{
      accrual,
      morn: morn !== null && morn !== void 0 ? morn : last.morn,
      dusk: dusk !== null && dusk !== void 0 ? dusk : last.dusk
    }, last, ...rest];
  }, []).reverse().slice(1, -1) // 这一步操作，将桩的id替换为篱笆的id，将发生额边界替换为发生额，这样就得到了被
  // 分解的分录。
  .map(({
    accrual,
    morn,
    dusk
  }, i, a) => ({
    accrual: a[i + 1] ? toFixed2(a[i + 1].accrual - accrual) : 0,
    morn,
    dusk
  })).slice(0, -1);
  return sortedIndex.map(({
    accrual,
    morn,
    dusk
  }) => {
    const newMorn = morns[morn].copy();
    const newDusk = dusks[dusk].copy();
    newMorn.accrual[mornCol] = accrual;
    newDusk.accrual[duskCol] = accrual;
    assignDest(newMorn, newDusk);
    return [newMorn, newDusk];
  });
}
;// CONCATENATED MODULE: ./src/Voucher/decompose-norm.js



const decompose = origEntries => {
  const copy = origEntries.map(entry => entry.copy());
  const decomp = new List();

  for (let i = 0; i < copy.length; i++) {
    copy[i].accrual.swap();
  }

  let acc = new Accrual();

  for (let start = 0, end = 0; end < copy.length; end++) {
    acc.add(copy[end].accrual);

    if (Math.abs(acc.diff()) < 1e-4) {
      let groupEntries = copy.slice(start, end + 1);
      const drRecs = groupEntries.filter(({
        accrual
      }) => accrual.dir() === 'dr');
      const crRecs = groupEntries.filter(({
        accrual
      }) => accrual.dir() === 'cr');
      const records = alternateDeduct({
        list: drRecs,
        col: 'dr'
      }, {
        list: crRecs,
        col: 'cr'
      }).flat();
      decomp.push(...records);
      start = end + 1;
    }
  }

  for (let i = 0; i < decomp.length; i++) {
    decomp[i].accrual.unswap();
    decomp[i].succ = origEntries;
  }

  return decomp;
};
;// CONCATENATED MODULE: ./src/Voucher/index.js


 // 我们有两种情况会用到Voucher：
// 1. 当我们读取序时帐并创建一条分录时
//    此时我们会直接使用构造函数。通过判断是否存在LineID来确定我们
//    是在创建一条凭证行还是在创建一个完整凭证。
// 2. 当我们汇总属于同一个凭证的若干行，并创建一条新的行时。
//    此时我们会使用静态方法from，在from中用到构造函数时可以保证lineID
//    是不存在的。

class Voucher_Voucher extends Entry_Entry {
  constructor({
    year,
    month,
    billDate,
    desc,
    voucherID,
    lineID,
    ...args
  } = {}, opts) {
    super(args, opts);
    this.billDate = billDate;
    this.year = year !== null && year !== void 0 ? year : billDate.getFullYear();
    this.month = month !== null && month !== void 0 ? month : billDate.getMonth();
    this.desc = desc;
    this.voucherID = lineID === undefined ? `${voucherID}` : `${this.year}-${this.month}-${voucherID}-${lineID}`;
  }

  copy(opts = {}) {
    return new Voucher_Voucher(this, opts);
  }

  add(voucher) {
    this.accrual.add(voucher.accrual);
  }

  static from(list, {
    voucherID,
    ListCons = Cascade_Cascade,
    decompose = false,
    emptyIdentity = false
  } = {}) {
    if (list.some(entry => !(entry instanceof Voucher_Voucher))) {
      throw Error('Voucher.from: voucher must be formed from list of Entry');
    }

    const voucher = new Voucher_Voucher(list[0], {
      emptyAccrual: true,
      emptyIdentity
    });

    for (let entry of list) {
      voucher.add(entry);
      entry.move(voucher, {
        pushSide: 'TAIL'
      });
    }

    if (voucherID !== undefined) {
      voucher.voucherID = voucherID;
    }

    if (decompose) {
      voucher.decomposeNorm();
    }

    return voucher;
  }

  copy() {
    return new Voucher_Voucher(this);
  }

  decomposeNorm() {
    this.succ = decompose(this.succ);
  }

}
;// CONCATENATED MODULE: ./src/util/index.js





function isInherited(desc, ances) {
  return desc === ances || desc.prototype instanceof ances;
}
/**
 * ## to2
 * 广泛应用的将浮点数化为取两位小数的定点数
 * @param {*} number 
 */

const util_to2 = number => {
  return parseFloat(number.toFixed(2));
};
/**
 * ## randomString
 * 按给定长度形成一个包含字母与数字的随机字符串
 * @param {number} len 
 */

const randomString = len => {
  return Math.random().toString(35).slice(2, 2 + len);
};
/**
 * ## randomIndex
 * 从列表中随机选择一个元素的index
 * @param {Array} list 
 */

const util_randomIndex = (list, {
  min = 0,
  max = list.length
} = {}) => {
  const index = list.length * Math.random();
  return Math.floor(Math.min(Math.max(index, min), max < 0 ? list.length - 1 + max : max));
};
/**
 * ## randomSelect
 * 从列表中随机选择若干不重复的元素
 * @param {Array} list 列表
 * @param {number} number 索要选择的元素数量。
 * ----
 * - 如果number为0到1之间的实数，则取其与列表长度乘积之floor；如果为大于1的实数，则为实际的数量；如果多于list的长度，则取list的长度。
 */

const util_randomSelect = (list, number = 0, {
  Cons = Array,
  remaining = false
} = {}) => {
  if (number === 0 || number === 1) {
    return list[util_randomIndex(list)];
  }

  const actualNumber = number > 0 && number < 1 ? Math.floor(list.length * number) : Math.min(number, list.length);
  const copy = list.slice();
  const res = new Cons();

  for (let i = 0; i < actualNumber; i++) {
    const [elem] = copy.splice(util_randomIndex(copy), 1);
    res.push(elem);
  }

  if (remaining) {
    return {
      selected: res,
      rest: copy
    };
  }

  return res;
};
const excerpt = (list, cond, Cons = Array) => {
  const result = new Cons();

  for (let i = 0; i < list.length; i++) {
    if (cond(list[i])) {
      result.push(list.splice(i, 1)[0]);
      i--;
    }
  }

  return result;
};
/**
 * ## createEntryData
 * ---
 * 模拟账套的一条记录，科目余额或发生额
 * 
 * 1. 可以用于单独生成凭证行，此时只会用到借贷方发生额
 * 2. 可以用于生成一行科目余额，此时需要指明期初期末借贷方向，以及类别
 * 3. 描述期初期末的方式可以在dirType中设定。
 * 
 * @param {Object} entry 一条记录 
 * @param {Object} opts 选项 
 */

const createEntryData = ({
  curr,
  code,
  name,
  itemCode,
  itemName,
  destCode,
  destName
} = {}, {
  dir = 'dr',
  dirType = 'single',
  item = false
} = {}) => {
  var _ref, _curr$code, _ref2, _curr$name;

  const cr = Math.random() * 100;
  const dr = Math.random() * 100;
  let balance;

  switch (dirType) {
    case 'direction':
      const opening = Math.random() * 100;
      const closing = util_to2(opening + (dir === 'dr' ? util_to2(dr - cr) : util_to2(cr - dr)));
      balance = {
        opening,
        closing,
        direction: dir
      };
      break;

    default:
      const [openingCr, openingDr] = dir === 'cr' ? [util_to2(Math.random() * 100), 0] : [0, util_to2(Math.random() * 100)];
      const [closingCr, closingDr] = [util_to2(openingCr + cr), util_to2(openingDr + dr)];
      balance = {
        openingCr,
        openingDr,
        closingCr,
        closingDr
      };
  }

  return {
    code: (_ref = (_curr$code = curr === null || curr === void 0 ? void 0 : curr.code) !== null && _curr$code !== void 0 ? _curr$code : code) !== null && _ref !== void 0 ? _ref : randomString(4),
    name: (_ref2 = (_curr$name = curr === null || curr === void 0 ? void 0 : curr.name) !== null && _curr$name !== void 0 ? _curr$name : name) !== null && _ref2 !== void 0 ? _ref2 : randomString(24),
    itemCode: itemCode !== null && itemCode !== void 0 ? itemCode : item ? randomString(4) : undefined,
    itemName: itemName !== null && itemName !== void 0 ? itemName : item ? randomString(24) : undefined,
    destCode: destCode !== null && destCode !== void 0 ? destCode : randomString(4),
    destName: destName !== null && destName !== void 0 ? destName : randomString(24),
    cr,
    dr,
    ...balance
  };
};
/**
 * ## createEntry
 * ---
 * 生成一条随机的Entry
 * 
 * @param {string} parentCode 上级科目的科目编码
 * @param {Function} EntryCons 构造一条entry的constructor
 * 
 */

const createEntry = (parentCode, {
  EntryCons = Entry
} = {}) => {
  const cateSpec = {
    code: `${parentCode}${randomString(2)}`,
    name: randomString(24)
  };
  const entry = new EntryCons({ ...createEntryData(),
    ...cateSpec
  }, {
    ListCons: Cascade
  });
  return entry;
};
/**
 * createCascadeEntries
 * ---
 * 生成一个级联列表
 * 
 * @param {*} opts 参数
 * * attempts : 测试数量
 */

const createCascadeEntries = ({
  attempts = 100,
  EntryCons = Balance
} = {}) => {
  let counter = attempts;
  let cateList = [];

  while (counter > 0) {
    if (cateList.length === 0) {
      cateList.push(createEntry('', {
        EntryCons
      }));
    }

    const {
      curr: {
        code
      }
    } = util_randomSelect(cateList);
    const newEntry = createEntry(code, {
      EntryCons
    });

    if (!cateList.map(({
      curr: {
        code
      }
    }) => code).includes(newEntry.curr.code)) {
      cateList.push(newEntry);
    }

    counter--;
  }

  cateList.shift();
  return cateList;
};
const createCascade = ({
  attempts = 100
} = {}) => {
  const cateList = createCascadeEntries({
    attempts
  });
  return Cascade.from(cateList);
};
const randomLenArray = (len, base = 0, ListCons = Array) => {
  return new ListCons(...Array(Math.floor(Math.random() * len + base)));
};
const formVoucher = (categories, {
  year,
  month,
  voucherID
} = {}) => {
  const voucherProp = {
    year: year !== null && year !== void 0 ? year : 2000 + Math.floor(Math.random() * 20),
    month: month !== null && month !== void 0 ? month : Math.ceil(Math.random() * 12),
    voucherID: voucherID !== null && voucherID !== void 0 ? voucherID : Math.floor(Math.random() * 20),
    billDate: new Date(),
    desc: 'yet another fake voucher'
  };
  const cateEnds = categories.filter(({
    succ
  }) => succ.length === 0).map(({
    curr: {
      code
    }
  }) => code);
  let selectedCates = [...new Set(util_randomSelect(cateEnds, 20))];
  let counter = Math.floor(Math.random() * 100) + 1;
  let entries = new Cascade();

  while (counter > 0) {
    const accrual = util_to2(Math.random() * 100);
    const [head, tail] = util_randomSelect(selectedCates, 2);
    entries.push(new Entry({
      code: head,
      dr: accrual
    }));
    entries.push(new Entry({
      code: tail,
      cr: accrual
    }));
    counter--;
  } // console.log(entries.map(({accrual}) => accrual).reduce((acc, elem) => acc.add(elem), new Accrual()));


  entries = entries.grip(({
    curr: {
      code
    }
  }) => code).grap(([, grouped]) => grouped.reduce((acc, elem) => {
    acc.accrual.add(elem.accrual);
    return acc;
  })).map((elem, index) => {
    elem.accrual.net();
    return new Voucher({ ...elem,
      ...voucherProp,
      lineID: index + 1
    });
  });
  return entries;
};
const createRules = (sources, targets, {
  ratio = 0.8,
  attempts
} = {}) => {
  const targetEndLevel = targets.flat().filter(({
    succ
  }) => succ.length === 0);
  const sourceFlatten = sources.flat();
  const {
    selected: samples,
    rest
  } = util_randomSelect(sourceFlatten, ratio, {
    Cons: Cascade,
    remaining: true
  });
  samples.sort(({
    path: a
  }, {
    path: b
  }) => a < b ? -1 : a > b ? 1 : 0);
  const subRules = samples.map(sample => new Rule({
    patt: sample.path,
    prop: 'path',
    cast: '=',
    dest: {
      name: 'dest',
      object: util_randomSelect(targetEndLevel)
    },
    action: (target, source) => {
      // console.log('MOVE', source, 'TO', target);
      source.move(target);
    }
  }));

  if (attempts > 0) {
    const pathSegs = samples.map(({
      path
    }) => path.split('/'));
    const pathMaxDepth = Math.max(...pathSegs.map(p => p.length));

    const padArray = (len, char) => Array(len).fill(char);

    const padPath = (path, len, char) => {
      const segs = path.split('/');
      return len > segs.length ? segs.concat(padArray(len - segs.length, char)).join('/') : path;
    };

    for (let i = 0; i < attempts; i++) {
      const pathLimit = Math.floor(Math.random() * pathMaxDepth);
      const selectedPath = subRules.grip(({
        patt
      }) => padPath(patt, pathLimit, '$$$')).keys().randomSelect().split('/');
      const prefix = selectedPath.slice(0, util_randomIndex(selectedPath, {
        min: 1
      })).join('/');
      if (prefix.includes('$$$')) continue;
      const newRule = new Rule({
        patt: `${prefix}/*`,
        prop: 'path',
        cast: '~/',
        cand: excerpt(subRules, ({
          patt
        }) => patt.startsWith(prefix) && !patt.endsWith(prefix))
      });
      subRules.push(newRule);
    }
  }

  return {
    sampled: samples,
    rest,
    rules: new Rule({
      cast: '*',
      cand: subRules
    })
  };
};
;// CONCATENATED MODULE: ./src/Cascade/index.js






class Cascade_Cascade extends List {
  constructor(...args) {
    super(...args);
  }

  static from(list, {
    EntryCons = Entry_Entry,
    ListCons = Cascade_Cascade
  } = {}) {
    if (!isInherited(EntryCons, Entry_Entry)) {
      throw Error('List.from: Entry constructor must inherits from Entry');
    }

    const cate = new Cascade_Cascade();

    for (let elem of list) {
      cate.push(new EntryCons(elem, {
        ListCons
      }));
    }

    return cate;
  }

  flat() {
    if (this.attr.form !== 'NESTED') {
      throw Error('Cascade.flat: cannot flat an unnested list');
    }

    const stack = [...this];
    const res = new Cascade_Cascade();

    while (stack.length) {
      const next = stack.shift();
      const {
        succ
      } = next;

      if (succ.constructor === Cascade_Cascade && succ.length > 0) {
        stack.unshift(...succ);
      }

      res.push(next);
    }

    return res;
  }

  nest({
    genKey,
    matchKey,
    nestKey
  } = {}) {
    if (this.some(({
      curr: {
        code
      }
    }) => typeof code !== 'string')) {
      throw Error('Cascade.nest: code must be string');
    }

    if (this.attr.form === 'NESTED') {
      throw Error('Cascade.nest: code must nested');
    }

    if (this.every(elem => !(elem instanceof Entry_Entry))) {
      throw Error('Cascade.nest: all elements must be Entry in order to nest');
    }

    const [genFunc, matchFunc] = genKey && matchKey ? [genKey, matchKey] : nestKey ? [rec => propFunc(rec, nestKey).length, (pred, succ) => propFunc(succ, nestKey).startsWith(propFunc(pred, nestKey))] : [({
      curr: {
        code
      }
    }) => code.length, ({
      curr: pred
    }, {
      curr: succ
    }) => succ.code.startsWith(pred.code)];

    for (let elem of this) {
      elem.succ = new Cascade_Cascade();
    } // grip使用了genFunc，将列表分为几代（Generation）
    // gens是分代的结果，分代结果应该是祖先在前，后继在后。


    const gens = this.orderBy(genFunc).grip(genFunc).grap(); // 对于所有分代

    let gen;

    for (gen = gens.pop(); gens.length > 0; gen = gens.pop()) {
      let preds = gens.pop(); // 在两代中间进行匹配

      while (gen.length > 0) {
        let succ = gen.pop();

        for (let pred of preds) if (matchFunc(pred, succ)) {
          succ.move(pred);
        }
      }

      gens.push(preds);
    }

    gen.trav(entry => {
      entry.getPath();
    }); // 返回祖先一代。

    gen.attr.form = 'NESTED';
    return gen;
  }

  trav(func = e => e, dir = 'PRE') {
    if (!['POST', 'PRE'].includes(dir)) {
      throw Error('Cascade.trav: direction must be either POST or PRE');
    }

    for (let [index, curr] of this.entries()) if (curr) {
      dir === 'PRE' && func(curr, index);

      try {
        curr.succ && curr.succ.trav(func, dir);
      } catch {
        console.log(curr);
      }

      dir === 'POST' && func(curr, index);
    }
  } // 按线索寻找Category中的某个元素。如果给定colName则按照colName，否则按照code
  // 返回值是一个list，如果给定了Path，长度和给定Path是一样的。如果未给定Path，则
  // 将Path按照code来寻找，以code所能匹配的最深的一级结束。
  // 
  // 如果在某一级按照当前path未能找到对应元素，那么从那一级之后的元素均为undefined。


  findEntry({
    code: markCode,
    path
  }, colName) {
    const pathElems = new List();
    const currList = this;

    if (colName !== undefined) {
      while (path.length > 0) {
        var _currElem$succ;

        const currElem = currList.find(({
          [col]: val
        }) => val === path.pop());
        pathElems.push(currElem);
        currList = (_currElem$succ = currElem === null || currElem === void 0 ? void 0 : currElem.succ) !== null && _currElem$succ !== void 0 ? _currElem$succ : [];
      }
    } else {
      while (currList !== undefined) {
        const currElem = currList.find(({
          code
        }) => markCode.startsWith(code));
        pathElems.push(currElem);
        currList = currElem === null || currElem === void 0 ? void 0 : currElem.succ;
      }
    }

    return pathElems;
  }

  toDict(colName) {
    const func = colName === undefined ? ({
      curr: {
        code
      }
    }) => code : typeof colName === 'string' ? ({
      [colName]: col
    }) => col : colName;
    return this.flat().map(elem => {
      const key = elem.path().map(func).join('/');
      return [key, elem];
    });
  }

  mergeFrom(sourceData, {
    type,
    rules,
    action
  } = {}) {
    if (type === 'indirect') {
      if (rules && rules.constructor === Rule_Rule) {
        return rules.match(sourceData);
      }
    } else {
      const sources = sourceData.attr.form === 'NESTED' ? sourceData.flat() : sourceData;
      const targets = this.attr.form === 'NESTED' ? this.flat() : this;
      let sourceKey, targetKey;

      if (rules === undefined) {
        sourceKey = 'curr.code';
        targetKey = 'curr.code';
      } else if (typeof rules === 'string') {
        sourceKey = rules;
        targetKey = rules;
      } else {
        var _ref, _rules$source, _ref2, _rules$target;

        sourceKey = (_ref = (_rules$source = rules.source) !== null && _rules$source !== void 0 ? _rules$source : rules.key) !== null && _ref !== void 0 ? _ref : 'curr.code';
        targetKey = (_ref2 = (_rules$target = rules.target) !== null && _rules$target !== void 0 ? _rules$target : rules.key) !== null && _ref2 !== void 0 ? _ref2 : 'curr.code';
      }

      const targetMap = {};

      for (let targ = targets.length - 1; targ >= 0; targ--) {
        var _targetMap$targKey;

        const targElem = targets[targ];
        const targKey = propFunc(targElem, targetKey);
        (_targetMap$targKey = targetMap[targKey]) !== null && _targetMap$targKey !== void 0 ? _targetMap$targKey : targetMap[targKey] = targElem;
      }

      const mergeAction = typeof action === 'function' ? action : merge_methods[action !== null && action !== void 0 ? action : 'MERGE'];

      for (let sour = sources.length - 1; sour >= 0; sour--) {
        const sourElem = sources[sour];
        const sourKey = propFunc(sourElem, sourceKey);
        const targElem = targetMap[sourKey];
        targElem && mergeAction(targElem, sourElem);
      }
    }
  }

}
;// CONCATENATED MODULE: ./src/Rule/index.js




function conform(orig = '', patt) {
  const origList = orig.split('/');
  const pattList = patt.split('/');
  let res = true;

  while (pattList.length > 0 && res) {
    // When original path has been consumed up. It's guranteed to
    // be false.
    if (origList.length === 0) {
      res = false;
      break;
    }

    const origSeg = origList.shift();
    const pattSeg = pattList.shift(); // If a pattern segment found to be an asterisk (*), means we have
    // finished all previous matching, and the * matches all remaining
    // parts of the original path. We stop here, and all posiible rest
    // part of pattern will be omitted.

    if (pattSeg === '*') {
      res = true;
      break;
    } // else we proceed to a normal matching. if the segments at same
    // position doesn't match, then a false result will be formed, and
    // the loop will stop.


    res = origSeg === pattSeg;
  }

  return res;
} // 默认的搬运方法


const carryMethods = {
  SELF: rec => [rec],
  NEXT: ({
    succ
  }) => succ,
  REST: ({
    succ
  }) => succ.flat(),
  LAST: ({
    succ
  }) => succ.flat().filter(({
    succ
  }) => succ.length === 0),
  CURR_CATE: ({
    succ
  }) => {
    const list = new Cascade_Cascade();
    succ.trav(rec => {
      if (rec.attr.level === 'CURR_CATE') list.push(rec);
    });
    return list;
  },
  DEST_CATE: ({
    succ
  }) => {
    const list = new Cascade_Cascade();
    succ.trav(rec => {
      if (rec.attr.level === 'DEST_CATE') list.push(rec);
    });
    console.log('DEST_CATES', list);
    return list;
  },
  DIRECTION: ({
    succ
  }) => {
    const list = new Cascade_Cascade();
    succ.trav(rec => {
      if (rec.attr.level === 'DIRECTION') list.push(rec);
    });
    console.log('DIRECTION', list);
    return list;
  }
}; // 默认的匹配方法

const castMethods = {
  TRUE: () => true,
  '*': () => true,
  FALSE: () => false,
  '!': () => false,
  '^>': (val, patt) => val.startsWith(patt),
  '^@': (val, patt) => patt.startsWith(val),
  '<$': (val, patt) => val.endsWith(patt),
  '@$': (val, patt) => patt.endsWith(val),
  '~': (val, patt) => val.includes(patt),
  '@': (val, patt) => patt.includes(val),
  '=': (val, patt) => patt === val,
  '~/': (val, patt) => conform(val, patt)
};

const merge = (action = 'MERGE', rec, dest) => {
  if (typeof action === 'string') {
    merge_methods[action](dest, rec);
    return [rec];
  } else if (typeof action === 'function') {
    action(dest, rec);
    return [rec];
  } else {
    throw Error('Invalid merging method');
  }
};

const carry = (action = 'SELF', rec) => {
  if (typeof action === 'string') {
    return carryMethods[action](rec);
  } else if (typeof action === 'function') {
    return action(rec);
  } else {
    throw Error('Invalid carrying method');
  }
};
/**
 * Rule Class
 * ----------
 * When the destination is givne, all other specficiation of next level
 * will be invalidated. The destination should be always associated to
 * an actual record.
 */


class Rule_Rule {
  constructor({
    prop = 'curr.name',
    patt,
    cast,
    cand,
    action,
    dest
  } = {}) {
    this.prop = prop;
    this.patt = patt;
    this.cast = cast;
    this.overProp = undefined;
    this.overCast = undefined;
    this.overSucc = undefined;
    this.succ = cand !== null && cand !== void 0 ? cand : new Cascade_Cascade();
    this.pred = undefined;

    if (typeof dest === 'string') {
      this.dest = {
        name: dest
      };
    } else if (typeof dest === 'object' && dest.object) {
      this.dest = dest;
    } else {
      this.dest = {};
    }

    this.action = action !== null && action !== void 0 ? action : this.succ.length === 0 ? 'MERGE' : 'SELF';
    this.attr = {};
  }

  move(dest) {
    this.pred = dest;
    dest.succ.push(this);
  }

  match(list, {
    overProp,
    overCast
  } = {}) {
    // # MATCH的工作原理
    // 
    // 1. 发起match动作的是top-level rule (TLR)，从原理上TLR不拒绝任何
    //    被匹配对象，而是送往下一层的规则进行后续匹配。
    // 
    // 2. 每层会通过find来找到匹配的next-level rule (NLR)，而并非进入到
    //    下一层的备选rule列表中循环查找。
    // 
    // 3. 如果当前rule没有NLR，那么会按照当前rule中指定的destination和对
    //    应的merge operation完成分配操作。
    //
    // 4. 每层rule可以指定一个carry方法，对于级联的记录可以进行展开、筛选等
    //    操作。特别需要注意的是这个carry方法apply于cast操作之前，原因仍然
    //    是每层rule并不是在匹配自己，而是在匹配下一层，因此需要在匹配之前完
    //    成NLR所接受的形式。
    const {
      patt,
      prop,
      cast,
      dest,
      succ,
      action
    } = this;

    for (let i = 0; i < list.length; i++) {
      var _ref, _ref2;

      const rec = list[i];
      const handledProp = (_ref = overProp !== null && overProp !== void 0 ? overProp : prop) !== null && _ref !== void 0 ? _ref : 'curr.name';
      const handledCast = (_ref2 = overCast !== null && overCast !== void 0 ? overCast : cast) !== null && _ref2 !== void 0 ? _ref2 : '=';
      const propVal = propPath(rec, handledProp);
      const castMethod = castMethods[handledCast];
      const castResult = castMethod(propVal, patt);

      if (!castResult) {// console.log(`NOT MATCHED @ [${handledProp} by (${propVal})] ${handledCast} [${patt}]`);
      } else if (!succ || succ.length === 0) {
        merge(action, rec, dest.object);
      } else for (let s = 0; s < succ.length; s++) {
        const subRule = succ[s];
        subRule.match(carry(action, rec), {
          overCast: this.overCast,
          overProp: this.overProp
        });
      }
    }
  }

  initDest(destList, destKey = 'curr.name') {
    const action = (target, source) => {
      target.dest = source;
    };

    this.succ.mergeFrom(destList, {
      rules: {
        target: 'dest',
        source: destKey,
        action
      }
    });
  }

}
;// CONCATENATED MODULE: ./src/index.js






 // export {util} from './util';

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(777);
/******/ })()
;